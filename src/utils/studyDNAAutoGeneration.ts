/**
 * Study DNA Auto-Generation Utilities
 * 
 * Automatically generates personas and protocol templates based on Study DNA configuration.
 */

import type { UserPersona, SavedProtocol, ProtocolVersion, SchemaBlock } from '../types/shared';
import type { SchemaBlock as FullSchemaBlock } from '../components/protocol-workbench/types';
import type { 
  StudyDesignType, 
  StudyDesignConfiguration,
  StatisticianPersonaTemplate, 
  ProtocolTemplateSuggestion 
} from '../types/studyDesigns';
import { generateStudyDNA } from './studyDesignDefaults';
import { convertSchemaBlocks, debugSchemaBlockFormat } from './schemaBlockAdapter';

/**
 * Auto-create a statistician persona from Study DNA template
 */
export function createPersonaFromStudyDNA(
  studyDesignType: StudyDesignType,
  projectId: string,
  projectName: string
): UserPersona {
  const studyDNA = generateStudyDNA(studyDesignType);
  const template = studyDNA.statisticianTemplate;
  
  const now = new Date();
  
  return {
    id: `persona-${projectId}-${Date.now()}`,
    name: template.name,
    role: template.role,
    permissions: template.permissions,
    preferences: {
      // Core persona configuration
      studyDesignType,
      focus: template.focus,
      description: template.description,
      
      // Project association
      projectId,
      projectName,
      autoGenerated: true,
      
      // Key responsibilities
      keyResponsibilities: template.keyResponsibilities,
      recommendedAnalyses: template.recommendedAnalyses,
      
      // AI Interpretation settings (based on study type)
      interpretationSettings: {
        focus: template.focus,
        conservativeLanguage: true,
        requireCitation: true,
        allowedInferences: getDefaultAllowedInferences(studyDesignType),
        disallowedInferences: getDefaultDisallowedInferences(studyDesignType),
      },
      
      // Language controls
      languageControls: {
        tone: 'socratic',
        confidenceLevel: 2, // Conservative by default
        neverWriteFullSections: true,
        forbiddenAnthropomorphism: true,
        jargonLevel: 'peer-review',
      },
      
      // Citation policy
      citationPolicy: {
        strictnessLevel: 'strict',
        requireSourceForClaim: true,
        allowHeuristic: false,
        maxUncitedSentences: 0,
        citationFormat: 'vancouver',
        requirePeerReviewed: true,
      },
    },
    createdAt: now,
    modifiedAt: now,
  };
}

/**
 * Get default allowed inferences based on study design type
 */
function getDefaultAllowedInferences(studyDesignType: StudyDesignType): string[] {
  const baseInferences = ['benchmark-comparison', 'descriptive-trend'];
  
  switch (studyDesignType) {
    case 'rct':
      return [
        ...baseInferences,
        'statistical-method-suggestions',
        'protocol-deviation-highlighting',
        'intention-to-treat-analysis',
      ];
    case 'cohort':
      return [
        ...baseInferences,
        'incidence-rate-calculation',
        'time-to-event-analysis',
        'risk-factor-identification',
      ];
    case 'case-series':
      return [
        ...baseInferences,
        'pattern-recognition',
        'hypothesis-generation',
        'outlier-identification',
      ];
    case 'laboratory':
      return [
        ...baseInferences,
        'quality-control-assessment',
        'measurement-precision-analysis',
        'reproducibility-evaluation',
      ];
    case 'technical-note':
      return [
        ...baseInferences,
        'literature-comparison',
        'case-synthesis',
        'educational-insights',
      ];
    default:
      return baseInferences;
  }
}

/**
 * Get default disallowed inferences (universal across all study types)
 */
function getDefaultDisallowedInferences(studyDesignType: StudyDesignType): string[] {
  const universalDisallowed = [
    'efficacy-claims',
    'safety-conclusions',
    'clinical-recommendations',
  ];
  
  // Case series and technical notes also disallow causal inference
  if (studyDesignType === 'case-series' || studyDesignType === 'technical-note') {
    return [...universalDisallowed, 'causal-inference'];
  }
  
  return universalDisallowed;
}

/**
 * Auto-generate protocol template from Study DNA
 */
export function createProtocolFromStudyDNA(
  studyDesignType: StudyDesignType,
  projectId: string,
  projectMetadata: {
    name: string;
    studyNumber: string;
    description?: string;
    phase?: string;
  },
  studyDesignConfig?: StudyDesignConfiguration
): SavedProtocol {
  const studyDNA = generateStudyDNA(studyDesignType);
  const template = studyDNA.protocolTemplate;
  const metadata = studyDNA.metadata;
  
  const now = new Date();
  const protocolId = `protocol-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  const versionId = `version-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  
  // Create schema blocks from template
  const schemaBlocks = createSchemaBlocksFromTemplate(template, metadata);
  
  // ðŸ”„ PHASE 2 FIX: Convert simplified blocks to full format for database compatibility
  console.log('ðŸ”„ Converting simplified schema blocks to full format...');
  debugSchemaBlockFormat(schemaBlocks, 'Before Conversion');
  
  const fullSchemaBlocks = convertSchemaBlocks(schemaBlocks);
  
  debugSchemaBlockFormat(fullSchemaBlocks, 'After Conversion');
  console.log(`âœ… Converted ${schemaBlocks.length} simplified blocks â†’ ${fullSchemaBlocks.length} full blocks`);
  
  // Determine sample size and duration from config or defaults
  let estimatedEnrollment = metadata.typicalSampleSize;
  let studyDuration = metadata.typicalDuration;
  
  // Override with study-specific config if available
  if (studyDesignConfig) {
    switch (studyDesignType) {
      case 'rct':
        if (studyDesignConfig.rct?.sampleSize) {
          estimatedEnrollment = `${studyDesignConfig.rct.sampleSize} participants`;
        }
        break;
      case 'case-series':
        if (studyDesignConfig.caseSeries?.numberOfCases) {
          estimatedEnrollment = `${studyDesignConfig.caseSeries.numberOfCases} cases`;
        }
        break;
      case 'cohort':
        if (studyDesignConfig.cohort?.followUpDuration) {
          studyDuration = studyDesignConfig.cohort.followUpDuration;
        }
        break;
      case 'laboratory':
        if (studyDesignConfig.laboratory?.numberOfReplicates) {
          estimatedEnrollment = `${studyDesignConfig.laboratory.numberOfReplicates} replicates`;
        }
        break;
      case 'technical-note':
        if (studyDesignConfig.technicalNote?.numberOfCases) {
          estimatedEnrollment = `${studyDesignConfig.technicalNote.numberOfCases} case${studyDesignConfig.technicalNote.numberOfCases > 1 ? 's' : ''}`;
        }
        break;
    }
  }
  
  // Create initial version
  const initialVersion: ProtocolVersion = {
    id: versionId,
    versionNumber: '1.0',
    status: 'draft',
    locked: false,
    createdAt: now,
    modifiedAt: now,
    createdBy: 'System (Auto-Generated)',
    modifiedBy: 'System (Auto-Generated)',
    metadata: {
      protocolTitle: projectMetadata.name,
      protocolNumber: projectMetadata.studyNumber,
      principalInvestigator: '',
      sponsor: '',
      studyPhase: projectMetadata.phase || metadata.typicalDuration,
      therapeuticArea: '',
      estimatedEnrollment,
      studyDuration,
    },
    schemaBlocks: fullSchemaBlocks,
    protocolContent: {
      primaryObjective: '',
      secondaryObjectives: '',
      inclusionCriteria: '',
      exclusionCriteria: '',
      statisticalPlan: generateDefaultStatisticalPlan(
        studyDesignType, 
        metadata, 
        studyDesignConfig
      ),
    },
    changeLog: `Auto-generated from ${metadata.label} template`,
    tags: [studyDesignType, 'auto-generated', 'template'],
    hasCollectedData: false,
    dataRecordCount: 0,
  };
  
  return {
    id: protocolId,
    name: projectMetadata.name,
    studyNumber: projectMetadata.studyNumber,
    description: projectMetadata.description || `${metadata.label} - ${metadata.description}`,
    currentVersion: initialVersion,
    versions: [initialVersion],
    createdAt: now,
    modifiedAt: now,
    tags: [studyDesignType, 'auto-generated'],
  };
}

/**
 * Create schema blocks from protocol template
 */
function createSchemaBlocksFromTemplate(
  template: ProtocolTemplateSuggestion,
  metadata: any
): SchemaBlock[] {
  const blocks: SchemaBlock[] = [];
  
  // Create sections from suggested sections
  template.suggestedSections.forEach((sectionName, index) => {
    const sectionBlock: SchemaBlock = {
      id: `section-${Date.now()}-${index}`,
      type: 'section',
      title: sectionName,
      description: getSectionDescription(sectionName, metadata),
      level: 1,
      children: [],
      metadata: {
        aiGenerated: true,
        confidence: 0.95,
        lastModified: new Date(),
        modifiedBy: 'System (Auto-Generated)',
        tags: ['auto-generated', 'template'],
      },
    };
    
    blocks.push(sectionBlock);
  });
  
  // Add endpoint blocks
  template.requiredEndpoints.forEach((endpoint, index) => {
    const endpointBlock: SchemaBlock = {
      id: `endpoint-${Date.now()}-${index}`,
      type: 'endpoint',
      title: endpoint.name,
      description: endpoint.description,
      level: 2,
      metadata: {
        dataType: endpoint.type,
        required: endpoint.type === 'primary',
        aiGenerated: true,
        confidence: 0.95,
        lastModified: new Date(),
        modifiedBy: 'System (Auto-Generated)',
        tags: ['auto-generated', endpoint.type],
      },
    };
    
    blocks.push(endpointBlock);
  });
  
  // Add variable blocks
  template.recommendedVariables.forEach((variable, index) => {
    const variableBlock: SchemaBlock = {
      id: `variable-${Date.now()}-${index}`,
      type: 'variable',
      title: variable.name,
      description: `${variable.category} - ${variable.type}`,
      level: 2,
      metadata: {
        dataType: variable.type,
        aiGenerated: true,
        confidence: 0.90,
        lastModified: new Date(),
        modifiedBy: 'System (Auto-Generated)',
        tags: ['auto-generated', variable.category, variable.type],
      },
    };
    
    blocks.push(variableBlock);
  });
  
  return blocks;
}

/**
 * Get section description based on section name
 */
function getSectionDescription(sectionName: string, metadata: any): string {
  const descriptions: Record<string, string> = {
    'Study Design & Randomization': `${metadata.label} design with ${metadata.typicalSampleSize} participants`,
    'Inclusion/Exclusion Criteria': 'Participant eligibility criteria',
    'Intervention Details': 'Description of study interventions',
    'Primary Endpoint': 'Primary outcome measure',
    'Secondary Endpoints': 'Secondary outcome measures',
    'Statistical Analysis Plan': 'Statistical methods and analysis plan',
    'Case Selection Criteria': 'Criteria for case inclusion in the series',
    'Demographics': 'Baseline demographic information',
    'Clinical Presentation': 'Clinical findings and presentation details',
    'Follow-Up Schedule': 'Schedule of follow-up visits and assessments',
    'Exposure Assessment': 'Methods for measuring exposure variables',
    'Experimental Design': 'Laboratory experimental design and controls',
    'Quality Control': 'Quality control procedures and standards',
    'Case Presentation': 'Detailed case presentation and clinical course',
    'Literature Review': 'Comparison with published literature',
  };
  
  return descriptions[sectionName] || '';
}

/**
 * Generate default statistical plan based on study design
 */
function generateDefaultStatisticalPlan(
  studyDesignType: StudyDesignType,
  metadata: any,
  studyDesignConfig?: StudyDesignConfiguration
): string {
  const plans: Record<StudyDesignType, string> = {
    'rct': `Statistical Analysis Plan for ${metadata.label}:

1. Primary Analysis: Intention-to-treat (ITT) analysis
2. Sample Size: ${metadata.typicalSampleSize}
3. Significance Level: Î± = 0.05 (two-sided)
4. Statistical Methods:
   - Categorical outcomes: Chi-square test or Fisher's exact test
   - Continuous outcomes: Two-sample t-test or Mann-Whitney U test
   - Time-to-event: Kaplan-Meier curves, log-rank test, Cox proportional hazards
5. Interim Analysis: As specified in protocol
6. Missing Data: Multiple imputation or sensitivity analysis
7. Subgroup Analysis: Pre-specified subgroups only`,

    'cohort': `Statistical Analysis Plan for ${metadata.label}:

1. Study Duration: ${metadata.typicalDuration}
2. Sample Size: ${metadata.typicalSampleSize}
3. Primary Analysis: Time-to-event analysis
4. Statistical Methods:
   - Incidence rates with 95% CI
   - Hazard ratios via Cox proportional hazards
   - Survival curves via Kaplan-Meier
   - Competing risks if applicable
5. Exposure Assessment: Baseline and time-varying covariates
6. Loss to Follow-Up: Sensitivity analysis
7. Confounding: Propensity score matching or multivariable adjustment`,

    'case-series': `Statistical Analysis Plan for ${metadata.label}:

1. Sample Size: ${metadata.typicalSampleSize}
2. Analysis Type: Descriptive statistics
3. Statistical Methods:
   - Frequencies and percentages for categorical variables
   - Median and IQR for continuous variables
   - Timeline visualization
   - Pattern recognition and hypothesis generation
4. Presentation: Individual case summaries and aggregate patterns
5. No formal hypothesis testing (descriptive study)`,

    'laboratory': `Statistical Analysis Plan for ${metadata.label}:

1. Replicates: ${metadata.typicalSampleSize}
2. Quality Control: As specified in protocol
3. Statistical Methods:
   - ANOVA for group comparisons
   - Coefficient of variation (CV) for precision
   - Bland-Altman plots for agreement
   - Intraclass correlation (ICC) for reliability
4. Quality Metrics:
   - Linearity (RÂ² â‰¥ 0.99)
   - Accuracy (95-105% recovery)
   - Precision (CV as specified)
5. Validation: Per regulatory guidelines (FDA, CLIA)`,

    'technical-note': `Analysis Plan for ${metadata.label}:

1. Case Count: ${metadata.typicalSampleSize}
2. Presentation Type: Narrative case report
3. Components:
   - Detailed case presentation
   - Imaging studies (if applicable)
   - Laboratory findings
   - Treatment timeline
   - Outcome documentation
4. Literature Comparison: PubMed search and comparative table
5. Educational Value: Key learning points and clinical pearls
6. No formal statistical analysis (case report)`,
  };
  
  // Apply study-specific config to the plan if available
  if (studyDesignConfig) {
    switch (studyDesignType) {
      case 'rct':
        if (studyDesignConfig.rct?.sampleSize) {
          plans['rct'] = plans['rct'].replace(
            `Sample Size: ${metadata.typicalSampleSize}`,
            `Sample Size: ${studyDesignConfig.rct.sampleSize} participants`
          );
        }
        break;
      case 'case-series':
        if (studyDesignConfig.caseSeries?.numberOfCases) {
          plans['case-series'] = plans['case-series'].replace(
            `Sample Size: ${metadata.typicalSampleSize}`,
            `Sample Size: ${studyDesignConfig.caseSeries.numberOfCases} cases`
          );
        }
        break;
      case 'cohort':
        if (studyDesignConfig.cohort?.followUpDuration) {
          plans['cohort'] = plans['cohort'].replace(
            `Study Duration: ${metadata.typicalDuration}`,
            `Study Duration: ${studyDesignConfig.cohort.followUpDuration}`
          );
        }
        break;
      case 'laboratory':
        if (studyDesignConfig.laboratory?.numberOfReplicates) {
          plans['laboratory'] = plans['laboratory'].replace(
            `Replicates: ${metadata.typicalSampleSize}`,
            `Replicates: ${studyDesignConfig.laboratory.numberOfReplicates} replicates`
          );
        }
        break;
      case 'technical-note':
        if (studyDesignConfig.technicalNote?.numberOfCases) {
          plans['technical-note'] = plans['technical-note'].replace(
            `Case Count: ${metadata.typicalSampleSize}`,
            `Case Count: ${studyDesignConfig.technicalNote.numberOfCases} case${studyDesignConfig.technicalNote.numberOfCases > 1 ? 's' : ''}`
          );
        }
        break;
    }
  }
  
  return plans[studyDesignType] || '';
}

/**
 * Helper function to get study DNA summary for display
 */
export function getStudyDNASummary(studyDesignType: StudyDesignType): {
  label: string;
  icon: string;
  statistician: string;
  sampleSize: string;
  duration: string;
} {
  const studyDNA = generateStudyDNA(studyDesignType);
  
  return {
    label: studyDNA.metadata.label,
    icon: studyDNA.metadata.icon,
    statistician: studyDNA.statisticianTemplate.name,
    sampleSize: studyDNA.metadata.typicalSampleSize,
    duration: studyDNA.metadata.typicalDuration,
  };
}